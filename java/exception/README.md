# EXCEPTION

Для checked - исключений необходим **либо** try - catch блок, **либо** декларация о выбросе исключений с помощью ключевого слова trows.

* <mark style="color:purple;">throws</mark> ставится в декларации метода: дескать, такое-то исключение может быть брошено;&#x20;
* <mark style="color:purple;">throw</mark> используется, когда программист сам хочет бросить исключение в данной точке кода; здесь потребуется new.

Преимущества механизма исключений133:&#x20;

* Обработка ошибок производится отдельно от «обычного» кода;&#x20;
* Ошибки передаются вверх по стеку;&#x20;
* Группирование и дифференциация ошибок согласно их типам.

Вслед за try-блоком обязан идти либо catch, либо finally – или и то и другое.

finally срабатывает последним и всегда, ЕСЛИ ТОЛЬКО в try или catch нет вызова System.exit().

* Если и catch и finally бросают по исключению, finally «перекрикивает» catch (в смысле, исключение из finally подавляет исключение, брошенное catch-блоком).&#x20;
* Неконтролируемые исключения не влияют на переопределение методов.&#x20;
* Переопределяющий метод не может бросать более широкое или «неродственное» контролируемое исключение.

Рефтайп диктует характер обработки контролируемого исключения:

```java
public abstract class Pet {
    /* other abstract methods */
    public abstract void voice() throws Exception;
}
public class TalkingDog extends Pet {
    public void voice(){
        System.out.println("Yeah?.."); // есть смысл посмотреть134
    }
}
class UltimateTease {
    public static void main(String[] args) {
        Pet myPet = new TalkingDog();
// myPet.voice(); // строка XXX; INVALID
    }
}
```

Строка XXX проваливает компиляцию, так как компилятор даже не догадывается, что актайп вообще не может возбудить контролируемое исключение; все, что видит компилятор – это рефтайп, который угрожает бросить ChE → вызов придется «завернуть» в TCF-конструкцию, или же вызывающий метод – в данном случае main() собственной персоной – должен объявить аналогичный выброс в своей декларации.

* С точки зрения исключений, правило переопределения методов работает противоположным образом в случае конструкторов.
* сначала исполняется finally, и лишь затем возбуждается Е в catch-блоке (в смысле, когда оно есть), ЗА ИСКЛЮЧЕНИЕМ ситуации, когда в самом finally стоит return или же он сам бросает E; в этом случае Е/return в finally подавляет Е/return в catch-блоке.
