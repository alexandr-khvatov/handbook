# this, super

super и this представляют собой ссылочные переменные, которые создаются и инициализируются самой виртуальной машиной для каждого объекта в памяти:

* &#x20;this всегда указывает на текущий объект…
* &#x20;в то время как super относится к супертипу этого объекта;

Чтобы из одного конструктора вызвать другой, используется форма <mark style="color:yellow;">this()</mark> или <mark style="color:yellow;">super()</mark>.

Для доступа к затененной переменной x (т.е. в пределах того же класса) мы пользуемся формой <mark style="color:yellow;">this</mark>.x, которая является типичной идиомой в конструкторах или методах, которые объявляют локальную переменную или аргумент, чье имя совпадает с именем instance-переменной:

```java
class Test {
    private Object a, b;

    public Test(Object a, Object b) {
        this.a = b;
        this.b = b;
    }

    public void setField_a(Object a) {
        this.a = a;
    }

}
```

Чтобы получить доступ к скрытой переменной x суперкласса, мы используем форму super.x. Переопределенный метод можно вызвать так: <mark style="color:yellow;">super.methodName()</mark>.

Может ли внук C вызвать дедушкин метод в A? То есть, допустима ли запись this.super.run()? Нет, не допустима: когда речь заходит о методах, мы не можем перескочить через ближайший верхний иерархический уровень, так как this относится к экземпляру, а не к типу.&#x20;

Отметим, что instance-переменные не знают такого ограничения, потому что переменные вообще невозможно переопределить: их можно только скрыть (hide). Отсюда следует, что для доступа к сокрытой переменной в предке ее надо «раскамуфлировать» за счет каста, например, ((A)c).var, который и даст нам переменную, которая была определена в A, даже если B постарался ее спрятать.&#x20;

Уже говорилось о том, что запись super.methodName() является корректным способом вызвать метод суперкласса из instance-метода подкласса; то же самое можно сделать для instance-инитера, конструктора или инициализатора instance-переменной. Но это работает только для классов.&#x20;

Так вот, чтобы вызвать суперинтерфейсный default-метод, нам придется указывать имя этого суперинтерфейса. Причем это будет возможно лишь в одном случае: когда данный суперинтерфейс напрямую имплементируется – или расширяется – тем типом, где сделан вызов:

```java
interface Laughable {
    default void getJoke(){ System.out.println("Ha-ha-ha!"); }
    static void makeJoke(){ System.out.println("A man walks into a bar..."); }
}

interface Coder extends Laughable {
    default void sayHello() {
// super.getJoke(); // это возможно только для классов
        Laughable.super.getJoke();
        Laughable.makeJoke();
    }
}

class JavaCoder implements Coder {
    public void sayHello() {
// super.getJoke(); // супертип JavaCoder’а вовсе не класс
        Laughable.makeJoke();
        Coder.super.sayHello();
    }
    public static void main(String[] args) {
        new JavaCoder().sayHello();
    }
}
```
