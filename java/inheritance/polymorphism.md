# Polymorphism

* Объект способен принимать различные формы, и его поведение будет в известной мере зависеть от типа ссылки, указывающей на этот объект. В отличие от методов и переменных, которые скрыты (hidden), на этапе исполнения переопределенные (overridden) методы будут заменены их переопределителями.
* Лишь наследуемые методы могут быть переопределены → private-методы удастся лишь скрыть.

{% hint style="warning" %}
Родительские private-методы не полиморфны и привязка к ним осуществляется на этапе компиляции → актайп-версия метода не исполняется.
{% endhint %}

{% hint style="success" %}
Абстрактные методы можно переопределить.
{% endhint %}

Суть полиморфизма глазами экзаменуемого:

* Для исполнения выбирается та версия метода, которая определена в классе фактического объекта;&#x20;
* В Java все вызовы non-private и non-final instance-методов являются виртуальными и потенциально полиморфными;
* Полиморфизм в Java проявляется тогда, когда «дочерний» метод имеет то же имя, что и переопределенный метод, но отличается от него своей бизнес-логикой.

Правила переопределения методов:

* <mark style="color:green;">Оба метода должны иметь одинаковую сигнатуру;</mark>&#x20;
* <mark style="color:green;">Переопределяющий метод не может иметь более жесткий уровень доступа;</mark>&#x20;
* <mark style="color:green;">Переопределяющий метод не может объявить новое или более широкое ChE;</mark>&#x20;
* <mark style="color:green;">Типы возвращаемого значения должны быть ковариантны.</mark>

{% hint style="success" %}
Типы возвращаемого значения переопределяющего и переопределенного методов должны в точности совпадать, если речь идет о примитиве. Если же методы возвращают объекты, то тип возвращаемого значения у переопределяющего метода может быть подклассом типа возвращаемого значения у переопределенного метода.
{% endhint %}

```java
class A {
    static void m1() {}
    void m2(){}
}
class B extends A{

//void m1() {} // INVALID: попытка переопределить static-метод
// static void m2(){} // INVALID: переопределитель сам static
}
```

Актайп и рефтайп:

* Актайп (actype) – иными словами, тип фактического (actual) объекта на этапе исполнения – определяет, какие именно характеристики присущи данному объекту в оперативной памяти.
* Рефтайп (reftype) – то есть тип ссылки (reference) на объект – указывает, какие методы и переменные доступны в этом объекте.

{% hint style="info" %}
Рефтайп задает, что имеется, актайп говорит, что исполняется.
{% endhint %}

{% hint style="info" %}
Новый объект? В первую очередь проверяем его рефтайп: это даст представление, на что объект способен и что ему недоступно.
{% endhint %}

В отличие от методов, переменные нельзя переопределить – но их можно СКРЫТЬ:

Какая именно переменная будет использована, зависит от рефтайпа (RT), то есть, от того, что стоит слева в записи

```java
RT obj = new AT(); // (где AT является потомком RT)
```

Какой метод сработает, зависит от актайпа (AT, т.е. того, что стоит справа):

```java
class A { int i = 10; int m1() { return i; } }
class B extends A { int i = 20; int m1() { return i; } }
class C extends B { int i = 30; int m1() { return i; } }
class Test{
public static void main(String[] args){
C o1 = new C();
B o2 = o1; // рефтайп B, актайп C
System.out.println( o1.m1() ); // печатает 30
System.out.println( o2.i ); // печатает 20
}
}
```

{% hint style="info" %}
Когда объявленная предком переменная не скрыта и получает новое значение в потомке, это новое значение отразится и в предке.
{% endhint %}

Такая попытка вызывает ошибку компиляции, если переменная final.

```java
class Grandpa {
// final String s = "Grandpa"; // не дает коду скомпилироваться
String s = "Grandpa";
}
class Parent extends Grandpa { }
class Child extends Parent {
void run(){
s = "Child"; // здесь s не скрыта, она всего
// лишь перекинута на др.объект
System.out.println(s + " "
+ this.s + " "
+ super.s + " "
+ new Parent().s); // Child Child Child Grandpa
}
public static void main(String[] args) {
new Child().run();
}
}
```

Была бы переменная s статической, печать бы дала Child Child Child Child.

Полиморфизм затрагивает и конструкторы \[ Прошу обратить внимание на аккуратность формулировки: она вовсе не утверждает, что конструкторы полиморфны (они же не наследуются); нет, речь идет о том, что конструкторы позволяют non-private и non-final instance-методам проявлять свою полиморфную природу. ]:

```java
class Parent {
Parent() { greet(); }
void greet() {
System.out.println(" Hello! "); // печатает null, т.к. greet() привязан
// к классу Child, а str в этой точке
// еще сохраняет дефолтное значение...
}
}
class Child extends Parent {
String str = " Hi! ";
void greet() { System.out.print(str); }
public static void main(String[] args){
Parent obj = new Child();
obj.greet(); // ...и лишь сейчас печатает Hi!
}
}
```

В данном примере безаргументный конструктор класса Parent вызывает метод greet(), который является виртуальным и, стало быть, выполняется согласно переопределяющей версии. Поскольку актайт объекта obj – это Child, первый вызов greet() печатает дефолтное значение переменной str, а вовсе не String " Hello! ", и лишь после того, как объект был полностью проинициализирован, повторный вызов того же метода выдает в консоль " Hi! ".&#x20;

Еще, пожалуйста, отметьте, что вызов переопределенного метода из конструктора (как это сделал Parent()) является порочной практикой, так как ведет к исполнению метода на еще не полностью сформированном объекте.
