# CASTING

Необходимость в приведении типов:

* С помощью кастинга мы заставляем ссылочную переменную вести себя как перемен- ную другого типа, чтобы обратиться к тем членам, которые не доступны по умолчанию:

```java
class Casting {
    public static void main(String[] args) {
        Object obj = new StringBuilder("Cast me plz... ");
// obj.append("Done!"); // INVALID
        ((StringBuilder) obj).append("Done!");
        System.out.println(obj);
    }
}
```

«Рефтайп задает, что имеется, актайп говорит, что исполняется». Хотя фактический тип (актайп) объекта – это StringBuilder, мы не можем вызвать на нем append(), поскольку этот метод не определен в классе Object → нужно скастировать переменную obj от Object к StringBuilder’у.

Правила кастинга между ссылочными типами:

* Расширение (widening или upcast: подкласс → суперкласс) не требует явного приведения типа.
* Сужение (narrowing или downcast: подкласс ← суперкласс) требует явного приведения типа.

{% hint style="info" %}
Рефтайп у́же актайпа, но каста нет? → ошибка компиляции!
{% endhint %}

Кастинг к неродственным типам:

Практически все пособия безапелляционно утверждают, что компилятор не допускает кастинг между типами, которые не связаны родственными узами, и точка. Но есть все-таки одно исключение, которое касается интерфейсов (см.ФАКУЛЬТ. ниже):

* Каст между неродственными классами всегда нелегален… ← <mark style="color:yellow;">важно</mark>

```java
class Test1 {
    public static void main(String[] args) {
        Short sH = new Short("1");
// Integer iN = (Integer) sH; // класс - класс; INVALID
        Number nU = sH;
    }
}
```

* Каст нефинального типа к неродственному интерфейсу всегда легален:

```java
interface I1 {}
interface I2 {}
class Test2 { // Test нефинален, иначе был бы комперр
    public static void main(String[] args) {
        Test2 t = new Test2(); // кстати, t можно сделать финальной
        I1 i1 = (I1) t; // класс - интерфейс; бросает CCE
        I2 i2 = (I2) i1; // интерфейс - интерфейс; бросает CCE
    }
}
```

Класс Test1 из предыдущих примеров иллюстрирует ошибку компиляции, возникающую при попытке скастировать Short к Integer: хотя все рапперы расширяют один и тот же родительский класс Number, с точки зрения наследования они друг другу не родственники. Последняя операция оказалась возможной оттого, что Short является родственником класса Number: он его потомок.

&#x20;Эта ясная и вполне однозначная картина мира трескается, едва мы решим скастировать нефинальный тип к интерфейсному, что и иллюстрирует класс Test2: несмотря на то, что все три типа совершенно незнакомы друг другу, оба каста оказались допустимы. Естественно, на этапе исполнения возникнет CCE, но по крайней мере с точки зрения компилятора все просто замечательно. Дело в том, что компилятор верит, что в какой- то прекрасный день некий потомок класса Test2 осуществит имплементацию одного из интерфейсов (а то и обоих).&#x20;

Сейчас вы знаете, что произойдет, если объявить Test2 финальным: поскольку у класса уже не может быть детей, первый каст немедленно становится нелегальным – ну а второй каст без первого и работать не будет…

{% hint style="info" %}
Каст между двумя неродственными интерфейсными типами, выполненный через non-final класс, всегда компилируется.
{% endhint %}

Даже после эксплицитного и корректного каста JVM вполне может бросить CastClassException на этапе исполнения, если кастируемый объект не является экземпляром целевого класса:

```java
class Parent {}
class Child extends Parent {}
class Test {
    public static void main(String[] args) {
        String s = "hello";
        Object o = s;
        StringBuilder sb = (StringBuilder) o; // VALID, но бросает CCE
        Parent p = new Parent();
        Child c = (Child) p; // VALID, но бросает CCE
    }
}
```

Первый каст в этом примере компилируется, однако актайп объекта o – это String, а не StringBuilder → поэтому типы конфликтуют, и на этапе исполнения возбуждается CCE. Ту же печальную картину мы наблюдаем и при втором касте…&#x20;

С другой стороны, мы могли бы заставить ссылки указывать на один и тот же объект, и тогда даункаст сработал бы без проблем:

```java
class Parent{}
class Child extends Parent {
    public static void main(String[] args) {
        Parent p = new Parent();
        Child c = new Child();
        p = c; // если закомментировать, будет CCE
        c = (Child) p;
    }
}

```

Приведение типов используется не только для того, чтобы ссылочной переменной стали доступны те или иные поля или методы, но и для решения проблемы с неоднозначной ссылкой:

```java
interface I1{ int A = 10; }
interface I2{ int A = 20; }
class Test implements I1, I2{
    public static void main(String[] args) {
// System.out.println( new Test().A ); // INVALID: "reference
// to A is ambiguous"
        System.out.println( I1.A ); // печатает 10
        System.out.println( ( (I1)new Test() ).A ); // печатает 10
        System.out.println( ( (I2)new Test() ).A ); // печатает 20
    }
}
```

{% hint style="info" %}
Еще один способ справиться с неоднозначной ссылкой – это указать полное (fully qualified) имя, что и проиллюстрировано первым валидным кастом в примере выше.
{% endhint %}

Кастинг помогает также добраться до тщательно спрятанного члена где-то на верхних этажах иерархической цепочки:

```java
class A {
    public String str = "Hello from A!";
}
class B extends A {
    private String str = "Hello from B!";
}
class C extends B{}
class Test{
    public static void main(String args[]){
        C c = new C();
// System.out.println(c.str); // INVALID
        System.out.println( ((A)c).str ); // Hello from A!
    }
}
```

Допустим, мы хотим обратиться к переменной str, объявленной в A. Первая печать в нашем примере проваливает поручение, потому что переменная str, задекларированная в B, скрывает (hides) переменную str из A; мало того, в классе B переменная str объявлена как private. Даже если бы она и не была private, мы все равно не смогли бы добраться до нее из-за хайдинга… Каст к типу A спешит на помощь!&#x20;

Одним словом, спецификатор final, примененный к классу, помогает сохранить его секреты… Я посоветовал бы подольше поиграть с этим примером, чтобы посмотреть как и что будет – или не будет – работать, если классы живут в разных пакетах и т.п.
