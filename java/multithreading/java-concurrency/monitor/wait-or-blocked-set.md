# wait|blocked set

### СИНХРОНИЗАЦИЯ МЕЖДУ ПОТОКАМИ

Если два потока будут выполнять код, который изменяет одну и ту же переменную, значение в переменной будет иметь непредсказуемое значение.

Классический пример такого поведения: два потока инкрементируют одно значение. Так как операция инкремента не выполняется за одну инструкцию процессора, то два потока изменят значение переменной произвольным образом — это называется race condition. Блоки кода, в которых может возникнуть race condition, называются критическими секциями. Чтобы избежать такой ситуации в Java предусмотрены способы синхронизации потоков.

Простейший способ синхронизации — концепция «монитора» и ключевое слово synchronized.  Изначально эта концепция была введена в языке Pascal. В Java такого класса «монитор», нет, однако у каждого объекта типа Object есть свой собственный «монитор». Так как у всех классов общий родитель — Object, все они имеют свой собственный «монитор».&#x20;

Концепция «монитор» внутри себя содержит 4 поля:&#x20;

1. locked типа boolean, которое показывает, захвачен монитор или нет;&#x20;
2. owner типа Thread — в это поле записывается поток, который захватил данный монитор;
3. blocked set — в это множество попадают потоки, которые не смогли захватить блокировку, или поток, который выходит из состояния wait;
4. wait set — в это множество попадают потоки, для которых был вызван метод wait.

![](<../../../.gitbook/assets/image (412).png>)

Blocked set, как и wait set, представляет собой неупорядоченное множество, не допускающее дубликатов. Т. е. в wait set или blocked set один и тот же поток не может быть записан два раза.

Поля монитора невозможно получить через рефлексию. У каждого объекта есть методы wait(), notify() и notifyAll(), которые этот объект унаследовал от класса Object. Использование ключевого слова synchronized гарантирует, что блоки кода будут выполняться только одним потоком в каждую конкретную единицу времени.&#x20;

Есть два варианта использования ключевого слова synchronized:&#x20;

1. Два потока выполняют код (так называемая критическая секция), который в каждый момент времени может выполнять только один поток.&#x20;
2. Один поток ожидает какое-то событие. Это поведение обеспечивается методами wait(), notify() и notifyAll().

Рассмотрим первую ситуацию: поток попадает в synchronized блок, выполняет критическую секцию и выходит из блока синхронизации. Ключевое слово synchronized всегда используется с объектом монитор. Сперва проверяются переменные locked и owner. Если эти поля false и null, соответственно,  они заполняются. Поле locked принимает значение true, а в поле owner записывается ссылка на захватывающий поток. Как только это произошло, считается, что поток выполнил код, который соответствует открывающей фигурной скобке synchronized блока, и поток занял эту блокировку. После того как поток выполнил код, который соответствует закрывающейся фигурной скобке блока синхронизации, переменные locked и owner в мониторе очищаются.&#x20;

Рассмотрим ситуацию, когда поток пытается захватить уже занятый монитор. Сначала проверяется, что переменная locked == true, затем сравнивается переменная owner. Если переменная owner не равна тому потоку, который хочет захватить монитор, то второй поток блокируется и попадает в blocked set монитора. Если сравнение переменных owner дает результат true, это значит, что один и тот же поток пытается захватить монитор повторно — в этом случае поток не блокируется. Такое поведение называется реентернабельностью. Пример такой ситуации — рекурсивные методы. После того, как блокировка освободилась, другой поток покидает blocked set и захватывает монитор. В blocked set может находится множество потоков. В этом случае выбирается произвольный поток, который далее может захватить монитор.

&#x20;Методы wait(), notify() и notifyAll() используются для ожидания выполнения какого-то условия, а не для передачи данных.

#### <mark style="color:green;">**Из состояния wait можно выйти несколькими способами:**</mark>

1. были вызваны методы notify() или notifyAll();
2. у потока вызвали метод interrupt(), после чего будет сгенерирован InterruptedException;
3. поток случайно проснулся (spurious wakeup);
4. по истечение таймаута, если использовали wait с таймаутом.

#### <mark style="color:green;">Есть два случая, когда поток может попасть в blocked set:</mark>

1. Блокировка занята другим потоком, как это было показано ранее.
2. Поток после ожидания в wait set продолжает выполнение, промежуточно попадая в blocked set. Это происходит потому, что другой поток, вызвавший notify() или notifyAll(), захватил блокировку.

{% hint style="success" %}
[https://senior.ua/articles/mnogopotochnost-v-java-lekciya-2-potoki-svoystva-potokov-blokirovki](https://senior.ua/articles/mnogopotochnost-v-java-lekciya-2-potoki-svoystva-potokov-blokirovki)
{% endhint %}
