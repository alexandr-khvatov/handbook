---
description: на HashMap
---

# HashSet

## <mark style="color:yellow;">add()</mark>, <mark style="color:yellow;">remove()</mark>, <mark style="color:yellow;">contains(), size</mark> 0(1)

* no order&#x20;
* null V OK
* uses hachCode()

В классе HashSet определены следующие конструкторы:

&#x20;HashSet()

&#x20;HashSet(Collection\<? extends Е>&#x20;

HashSet(int емкость)&#x20;

HashSet(int емкость, float коэффициент\_заполнения)

&#x20;В первой форме конструктора хеш-множество создается по умолчанию.&#x20;

Во второй форме хеш-множество инициируется содержимым заданной коллекции с.

&#x20;В третьей форме задается емкость хеш-множества (по умолчанию - 16),

&#x20;а в четвертой в качестве аргументов конструктора задается емкость хеш-множества и коэффициент\_ заполнения, иначе называемый емкостью загрузки.&#x20;

Коэффициент заполнения должен быть в пределах от О. О до 1. О, которые определяют, насколько заполненным должно быть хеш-множество, прежде чем будет изменен его размер.&#x20;

<mark style="color:green;">В частности, когда количество элементов становится больше емкости хеш-множества, умноженной на коэффициент заполнения, такое хеш-множество расширяется.</mark> В конструкторах, которые не принимают коэффициент заполнения в качестве параметра, выбирается значение этого коэффициента, равное <mark style="color:green;">0.75</mark>.

В классе HashSet не определяется никаких дополнительных методов, помимо тех, что предоставляют его суперклассы и интерфейсы.&#x20;

Следует также иметь в виду, что класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования сам по себе обычно не приводит к созданию отсортированных множеств. Если же требуются сортированные множества, то для этой цели лучше выбрать другой вид коллекции, например TreeSet.

![](<../../../../.gitbook/assets/image (343).png>)
